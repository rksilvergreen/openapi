# OpenAPI / JSON Schema – Complete Schema Graph Architecture  
### Structural Graphs • Applicator Graphs • $ref Resolution • SchemaNode Content  
_Comprehensive consolidated design document_

---

# 1. Overview

This document is the unified, expanded summary of everything discussed so far about:

- **SchemaNode design** (where schema content lives)  
- **Structural Graphs** (literal AST + resolved structural graph)  
- **Applicator Graph** (typed edges representing logical combinations)  
- **$ref resolution** (internal & external)  
- **Graph traversal semantics**  
- **Cycle handling**  

It forms the foundation of a robust OpenAPI/JSON Schema validator, analyzer, or code generator.

---

# 2. SchemaNode — Where Schema Content Lives

A `SchemaNode` represents *the actual schema object* as defined in YAML/JSON.

It MUST store:

- its **full raw contents** (`type`, `properties`, `items`, constraints, etc.)
- its **location** (`documentUri`, `jsonPointer`)
- any **parsed/normalized derived fields** (optional, but useful)

Example structure:

```ts
interface SchemaNode {
  id: SchemaId;             // e.g. "file://openapi.yaml#/components/schemas/User"

  documentUri: string;      // which file this schema came from
  jsonPointer: string;      // where inside the document it lives

  raw: any;                 // full raw schema object

  // Convenient extracted fields
  type?: string | string[];
  properties?: Record<string, any>;
  items?: any;
  additionalProperties?: any;
  // ... plus any constraints (minLength, maximum, pattern, etc.)
}
```

### Purpose of SchemaNode
- Holds **all the schema’s constraints and fields**  
- Does **not** determine relationships between schemas  
- Graphs point **to SchemaNode IDs**, not raw objects

---

# 3. The Two Structural Schema Graphs

There are *two* distinct structural graphs that serve different purposes.

---

## 3.1 Literal Structural AST (Tree)

Generated by following **literal nested schema objects** only:

- `properties`
- `items`
- `additionalProperties`
- `patternProperties`
- `prefixItems`
- `contains`
- `propertyNames`

Characteristics:

- Always a **tree**
- `$ref` is treated as a **leaf string value**, not expanded
- Per-document, it is **acyclic**

Used for:

- Syntax validation  
- Indexing  
- Document-scoped introspection  

### StructuralEdge
Each parent-child relationship is represented explicitly:

```ts
type StructuralKind =
  | "property"
  | "patternProperty"
  | "additionalProperties"
  | "items"
  | "prefixItems"
  | "contains"
  | "propertyNames"
  | "unevaluatedProperties"
  | "unevaluatedItems";

interface StructuralEdge {
  from: SchemaId;
  to: SchemaId;
  kind: StructuralKind;
  key?: string;            // property name, pattern, etc.
  index?: number;          // for prefixItems[index]
  sourcePath: string;      // JSON Pointer inside the parent schema
}
```

The literal structural graph:

```ts
Map<SchemaId, StructuralEdge[]>
```

---

## 3.2 Resolved Structural Graph (Graph)

When exploring the structure of schemas (e.g., for codegen), `$ref` is followed *as if referenced schemas were structurally nested*.

Characteristics:

- No longer a tree — now a **graph**
- Cycles possible
- Requires cycle detection

Used for:

- Structural introspection  
- Enumerating nested properties  
- Generating typed models  
- Schema visualization  

The resolved structural graph is conceptually:

```
structuralEdges + $ref edges
```

---

# 4. Applicator Graph (Logical Composition Graph)

Applicators define how schemas compose **logically**, not structurally.

Applicator keywords:

- `allOf`
- `anyOf`
- `oneOf`
- `not`
- `if`, `then`, `else`
- `dependentSchemas`
- `$ref` (logical redirection)

This graph is required for:

- Validation  
- Satisfiability reasoning  
- Semantic analysis  
- Constraints propagation  
- Logical simplification  

## Typed ApplicatorEdge

```ts
type ApplicatorKind =
  | "allOf"
  | "anyOf"
  | "oneOf"
  | "not"
  | "if"
  | "then"
  | "else"
  | "dependentSchemas"
  | "$ref";

interface ApplicatorEdge {
  from: SchemaId;
  to: SchemaId;
  kind: ApplicatorKind;

  index?: number;         // allOf[0], oneOf[2], etc.
  key?: string;           // map-based applicators
  sourcePath: string;     // JSON Pointer
}
```

Applicator graph:

```ts
Map<SchemaId, ApplicatorEdge[]>
```

### Why typed edges matter
Because analysis differs by applicator:

- `allOf` = intersection  
- `anyOf` = union (at least one)  
- `oneOf` = XOR  
- `not` = negation  
- `if → then/else` = conditional logic  

Without typed edges, graphs lose meaning.

---

# 5. Multi-Document Architecture & Lazy $ref Resolution

## Pass 1 — Document Indexing (No $ref following)

For each encountered document:

1. Parse YAML/JSON  
2. Walk its literal AST  
3. For every schema object:
   - create a `SchemaNode`
   - extract structural edges
   - extract raw applicator occurrences
   - record raw `$ref` strings

At this point:

- All structures remain **trees**  
- No `$ref` edges followed  

External docs are indexed **only when $ref references them**.

---

## Pass 2 — Reference Resolution

For each `$ref`:

1. Resolve URI / file path  
2. If not already indexed:
   - Load external document
   - Run Pass 1 (index it)
3. Map `$ref` → target `SchemaId`
4. Add ApplicatorEdge with `kind="$ref"`  
5. Optionally treat `$ref` as structural (when exploring structure)

Connecting `$ref` edges is what turns trees into **graphs**.

---

# 6. Graph Lifecycle

Before `$ref` resolution:

- structuralChildren → tree  
- applicatorChildren → tree  
- refEdges → unresolved strings  

After `$ref` resolution:

- applicator graph → **graph** (cycles allowed)  
- resolved structural graph → **graph** (if `$ref` used structurally)  
- literal AST remains a **tree**  

---

# 7. Cycle Handling

## Applicator Graph Cycles (during validation)
Use:

- `(schemaId, instanceLocation)` memoization  
- `inProgress` recursion detection  

On recursion:
- return fixpoint (`true`)  
or  
- mark recursive path  

This prevents infinite recursion in recursive schemas.

---

## Resolved Structural Graph Cycles
Standard DFS cycle detection:

- track visited schema IDs  
- do not revisit nodes  

Used for:

- structure listing  
- code generation  
- visualization  

---

# 8. Why SchemaNode + Typed Edges Is the Correct Architecture

### SchemaNode holds:
- type
- constraints
- metadata
- raw OpenAPI/JSON Schema object

### StructuralEdge expresses:
- *where children appear structurally*

### ApplicatorEdge expresses:
- *how schemas combine logically*

Both are necessary:

- You cannot navigate structure without `StructuralEdge`
- You cannot analyze composition or validate without `ApplicatorEdge`
- You cannot know schema meaning without `SchemaNode`

Graphs express **relationships**.  
Nodes express **content**.

This separation is what makes your validator clean, modular, fast, and correct.

---

# 9. Final Architecture Summary

```
            ┌──────────────────────┐
            │      SchemaNode      │  ← raw schema content
            └──────────────────────┘
                 ↑          ↑
         structural        applicator
           edges             edges
                 │          │
                 ▼          ▼
        Structural Graph   Applicator Graph
   (Tree → Graph w/refs)   (Always a Graph)
```

- **Literal Structural AST** — pure syntax tree (no refs expanded)  
- **Resolved Structural Graph** — structure + refs (graph)  
- **Applicator Graph** — logical composition (graph, typed edges)  

This architecture matches how serious schema engines (validators, normalizers, generators) are built.

---

# 10. Ready to Extend

If you want, I can add:

- A **visual diagram** (PNG/SVG)
- A **TypeScript/Rust class skeleton**
- A **walkthrough of real JSON Schema examples**
- A **validation engine pseudocode**
- A **schema normalization algorithm section**

Just tell me.
